# 3.5 BitTorrent 协议

BitTorrent（简称BT）是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。而在 FTP、HTTP 协议中，每个下载者从 FTP 或 HTTP 服务器处下载自己所需要的文件，各个下载者之间没有交互。当非常多的用户同时访问和下载服务器上的文件时，由于 FTP 服务器的处理能力和带宽的限制，下载速度会急剧下降，有的用户根本访问不了服务器。BT协议与FTP协议不同，它的特点是下载的人越多下载的速度越快，其原因在于每个下载者将已下载的数据提供给其他下载者下载，它充分利用了用户的上载带宽。BT协议通过一定的策略保证上传的速度越快，下载的速度也越快。


## 3.5.1 基于 BT 协议的系统实现

基于 BT 协议的系统由以下几个实体构成:

+ Web 服务器。
+ 种子文件。
+ Tracker服务器。
+ 原始文件提供者。
+ 网络浏览器。
+ 下载者。

Web 服务器上保存着种子文件，下载者使用网络浏览器（如IE浏览器）从 Web 服务器上下载种子文件。种子文件，又称为元原文件或 metafile，它保存了共享文件的一些信息，如共享文件的文件名、文件大小、Tracker 服务器的地址。种子文件通常很小，一般大小为 1GB 的共享文件，其种子文件不足100KB，种子文件以`.torrent`为后缀。Tracker 服务器保存着当前下载某共享文件的所有下载者的 IP 和端口。原始文件提供者提供完整的共享文件供其他下载者下载，它也被称为种子，种子文件就是提供者使用 BT 客户端生成的。每个下载者通过运行BT客户端软件下载共享文件。我们把某个下载者本身称为客户端，把其他下载者称为 peer。

BT 客户端下载一个共享文件的过程是：客户端首先解析种子文件，获取待下载的共享文件的一些信息，其中包括 Tracker 服务器的地址。然后客户端连接 Tracker 获取当前下载该文件的所有下载者的 IP 和端口。之后客户端根据 IP 和端口连接其他下载者，从它们那里下载文件，同时把自己已下载的部分提供给其他下载者下载。

共享文件在逻辑上被划分为大小相同的块，称为 piece，每个 piece 的大小通常为256KB。对于共享文件，文件的第1字节到第 256K（即262144）字节为第一个 piece，第 256K＋1 字节到第 512K 字节为第二个piece，依此类推。种子文件中包含有每个 piece 的 hash 值。BT 协议规定使用 SHA1 算法对每个piece 生成20字节的 hash 值，作为每个 piece 的指纹。每当客户端下载完一个 piece 时，即对该 peice 使用 SHA1 算法计算其 hash 值，并与种子文件中保存的该 peice 的 hash 值进行比较，如果一致即表明下载了一个完整而正确的 piece。一旦某个 piece 被下载，该 piece 即提供给其他 peer 下载。在实际上传和下载中，每个 piece 又被划分为大小相同的 slice，每个 slice 的大小固定为16KB（16384字节）。peer 之间每次传输以 slice 为单位。


## 3.5.2 B 编码

种子文件和 Tracker 的返回信息都是经过 B 编码的。要解析和处理种子文件以及 Tracker 的返回信息，首先要熟悉B编码的规则。B 编码中有4种类型：字符串、整型、列表、字典:

+ 字符串的编码格式为：<字符串的长度>:<字符串>，其中<>括号中的内容为必需。例如，有一个字符串spam，则经过B编码后为`4:spam`。
+ 整型的编码格式为：i<十进制的整型数>e，即 B 编码中的整数以i作为起始符，以 e 作为终结符，i 为 integer 的第一个字母，e 为 end 的第一个字母。例如，整数3，经过 B 编码后为`i3e`，整数 −3 的 B 编码为`i−3e`，整数0的 B 编码为`i0e`。注意`i03e`不是合法的B编码，因为03不是十进制整数，而是八进制整数。
+ 列表的编码格式为：l<任何合法的类型>e，列表以 l 为起始符，以 e 为终结符，中间可以为任何合法的经过 B 编码的类型，l 为 list 的第一个字母。例如，列表`l4:spam4:eggse`表示两个字符串，一个是 spam，一个是 eggs。
+ 字典的编码格式为：d<关键字><值>e，字典以 d 为起始符，以 e 为终结符，关键字是一个经过 B 编码的字符串，值可以是任何合法的 B 编码类型，在 d 和 e 之间可以出现多个关键字和值对，d 是dictionary 的第一个字母。例如，`d4:spaml3:aaa3:bbbee`，它是一个字典，该字典的关键字是 spam，值是一个列表（以 l 开始，以 e 结束），列表中有两个字符串 aaa 和 bbb。又如：`d9:publisher3:bob17:publisher-webpage15:www.example.come`，它也是一个字典，第一个关键字是 publisher，对应的值为 bob，第二个关键字是 publisher-webpage，对应的值是www.example.com。


## 3.5.3 种子文件结构

种子文件包含了提供共享的文件的一些信息，它以`.torrent`为后缀名，种子文件也被称为元信息文件或 metafile，它是经过 B 编码的。种子文件事实上就是一个 B 编码的字典，它含有以下关键字:

+ info              
	+ 该关键字对应的值是一个字典，它有两种模式，singel file 和 multiple file ，文件模式和多文件模式。 单文件模式是指待共享的文件只有一个，多文件模式是指提供共享的不止一个文件，而是两个或两个以上。如使用 BT 软件下载一部影片时，影片的上下部可能分别放在不同的文件里。
+ announce          
	+ 该关键字的值为 Tracker 的 URL。
+ announce－list    
	+ 可选，它的值存放的是备用 Tracker 的 URL。
+ creation－date    
	+ 可选，该关键字对应的值存放的是创建种子文件的时间。
+ comment           
	+ 可选，它的值存放的是种子文件制作者的备注信息，对于下载来说，该关键字基本没有用处。
+ created by        
	+ 可选，该关键字对应的值存放的是生成种子文件的BT客户端软件的信息，如客户端名、版本号等

info 是最重要的一个关键字，它的值是一个字典包含关键字如下：

+ piece length
	+ 每个 piece 的长度，它的值是一个B编码的整型，该值通常为`i262144e`，即 256K，也有可能为 512K 或 128K。
+ pieces
	+ 对应的值为一个字符串，它存放的是各个 piece 的 hash 值，这个字符串的长度一定是20的倍数，因为每个 piece 的 hash 值的长度为20字节。
+ private
	+ 该值如果为1，则表明客户端必须通过连接 Tracker 来获取其他下载者，即 peer 的 IP 地址和端口号；如果为0，则表明客户端还可以通过其他方式来获取 peer 的IP地址和端口号，如 DHT 方式。DHT 即分布式哈希表（Distribute Hash Tabel），它是一种以分布式的方式来获取 peer 的方法，现在许多 BT 客户端既支持通过连接 Tracker 来获取 peer，也支持通过 DHT 来获取 peer。如果种子文件中没有 private 这个关键字，则表明不限制一定要通过连接 Tracker 来获取 peer。

对于单文件模式的种子文件，info 的值还含有的关键字：

+ name
	+ 共享文件的文件名，也就是要下载的文件的文件名
+ length
	+ 共享文件的长度，以字节为单位
+ md5sum
	+ 可选，它是共享文件的 md5 值，这个值在 BT 协议中根本没有使用。

对于多文件模式的种子文件，info 的值还含有的关键字：

+ name
	+ 存放所有共享文件的文件夹名
+ files
	+ 它的值是一个列表，列表中含有多个字典，每个共享文件为一个字典。该字典中含有三个关键词


files 的每个共享文件为一个字典字典的关键词:

+ length
	+ 共享文件的长度，以字节为单位
+ md5sum
	+ 可选，同上
+ path
	+ 存放的是共享文件的路径和文件名

## 3.5.4 与 Tracker 交互

完成解析种子文件并从中获取 Tracker 服务器的 URL 后，即可开始与 Tracker 进行交互。与Tracker 进行交互主要有两个目的：一是将自己的下载进度告知给 Tracker 以便 Tracker 进行一些相关的统计；二是获取当前下载同一个共享文件的 peer 的 IP 地址和端口号。

客户端使用 HTTP 协议与 Tracker 进行通信。Tracker 通过 HTTP 的`GET`方法获取请求，请求的构成为 Tracker 的 URL 后面跟一个？以及参数和值对。，如`http://qq.com/announce?param1=value1&param2=value2`。

在客户端发往 Tracker 的 GET 请求中，通常包含参数：

+ info_hash
	+ 与种子文件中 info 关键字对应的值，通过 SHA1 算法计算其 hash 值，该 hash 值就是 info_hash 参数对应的值，该 hash 值的长度固定为20字节
+ peer_id
	+ 每个客户端在下载文件前以随机的方式生成的20字节的标识符，用于标识自己，它的长度也是固定不变的
+ port
	+ 监听端口号，用于接收其他 peer 的连接请求
+ uploaded
	+ 当前总的上传量，以字节为单位
+ downloaded
	+ 当前总的下载量，以字节为单位
+ left
	+ 还剩余多少字节需要下载，以字节为单位
+ compact
	+ 该参数的值一般为1。
+ event
	+ 它的值为 started、completed、stopped 其中之一。客户端第一次与 Tracker 进行通信时，该值为 started；下载完成时，该值为 completed；客户端即将关闭时，该值为 stopped
+ ip
	+ 可选，将客户端的IP地址告知给 Tracker，Tracker 可以通过分析客户端发给 Tracker 的 IP 数据包来获取客户端的 IP 地址，因此该参数是可选的，一般不用指明客户端的 IP
+ numwant
	+ 可选，希望 Tracker 返回多少个 peer 的 IP 地址和端口号。如果该参数缺省，则默认返回50个 peer 的 IP 地址和端口号
+ key
	+ 可选，它的值为一个随机数，用于进一步标识客户端。因为已经由 peer_id 来标识客户端，因此该参数一般不使用
+ trackerid
	+ 可选，一般不使用


Tracker 服务器的返回信息是一个经过 B 编码的字典:

+ failure reason
	+ 该关键字对应的值是一个可以读懂的字符串，指明`GET`请求失败的原因，如果返回信息中含有这个关键字，就不会再包含其他任何关键字
+ warnging message
	+ 该关键字对应的值是一个可以读懂的警告字符串
+ interval
	+ 指明客户端在下一次连接 Tracker 前所需等待的时间，以秒为单位
+ min interval
	+ 指明客户端在下一次连接 Tracker 前所需等待的最少时间，以秒为单位
+ tracker id
	+ 指明 Tracker 的 ID
+ complete
	+ 一个整数，指明当前有多少个 peer 已经完成了整个共享文件的下载
+ incomplete
	+ 一个整数，指明当前有多少个 peer 还没有完成共享文件的下载
+ peers
	+ 返回各个 peer 的 IP 和端口号，它的值是一个字符串。首先是第一个 peer 的 IP 地址，然后是其端口号；接着是第二个 peer 的 IP 地址，然后是其端口号；依此类推


## 3.5.5 peer 之间的通信协议

peer 之间的通信协议又称为 peer wire protocal，即 peer 连线协议，它是一个基于 TCP 协议的应用层协议。

为了防止有的 peer 只下载不上传，BitTorrent 协议建议，客户端只给那些向它提供最快下载速度的4个 peer上传数据。简单地说就是谁向我提供下载，我也提供数据供它下载；谁不提供数据给我下载，我的数据也不会上传给它。客户端每隔一定时间，比如10秒，重新计算从各个 peer 处下载数据的速度，将下载速度最快的4个 peer 解除阻塞，允许这4个 peer 从客户端下载数据，同时将其他 peer 阻塞。

一个例外情况是，为了发现下载速度更快的 peer，协议还建议，在任一时刻，客户端保持一个优化非阻塞 peer，即无论该 peer 是否提供数据给客户端下载，客户端都允许该 peer 从客户端这里下载数据。由于客户端向 peer 上传数据，peer 接着也允许客户端从 peer 处下载数据，并且下载速度超过4个非阻塞 peer 中的一个。客户端每隔一定的时间，如30秒，重新选择优化非阻塞 peer。

当客户端与 peer 建立 TCP 连接后，客户端必须维持的几个状态变量:

+ am_chocking
	+ 该值若为1，表明客户端将远程 peer 阻塞。此时如果 peer 发送数据请求给客户端，客户端将不会理会。也就是说，一旦将 peer 阻塞，peer 就无法从客户端下载到数据；该值若为0，则刚好相反，即表明 peer 未被阻塞，允许 peer 从客户端下载数据
+ am_interested
	+ 该值若为1，表明客户端对远程的 peer 感兴趣。当 peer 拥有某个 piece，而客户端没有，则客户端对 peer 感兴趣。该值若为0，则刚好相反，即表明客户端对 peer 不感兴趣，peer 拥有的所有 piece，客户端都拥有
+ peer_chocking
	+ 该值若为1，表明 peer 将客户端阻塞。此时，客户端无法从 peer 处下载到数据。该值若为0，表明客户端可以向 peer 发送数据请求，客户端将进行响应
+ peer_interested
	+ 该值若为1，表明 peer 对客户端感兴趣。也即客户端拥有某个 piece，而 peer 没有。该值若为0，表明 peer 对客户端不感兴趣

当客户端与peer建立TCP连接后，客户端将这几个变量的值设置为。

	am_chocking     = 1。
	am_interested  = 0。
	peer_chocking  = 1。
	peer_interested = 0。

当客户端对 peer 感兴趣且 peer 未将客户端阻塞时，客户端可以从 peer 处下载数据。当 peer 对客户端感兴趣，且客户端未将 peer 阻塞时，客户端向 peer 上传数据。

除非另有说明，所有的整数型在本协议中被编码为4字节值（高位在前低位在后），包括在握手之后所有信息的长度前缀。

## 3.5.6 关键算法和策略

### 流水线作业

BT 协议作为一种构建在 TCP 协议上的应用层协议，可以通过流水线作业来提高数据传输的效率。具体而言，当客户端向 peer 发送数据请求时（即发送 request 消息），一次请求多个 slice（即在一个数据包中发送多个 request 消息请求多个 slice）。假如客户端一次只发送一个 slice 请求，则peer 给客户端发送完一个 slice 的数据后就进入等待，等待客户端发送新的数据请求。如果一次发送多个 slice 请求，则 peer 发送完一个 slice 后接着发送下一个 slice，从而避免了等待，提高了数据传输的效率。事实上，HTTP 协议的1.1版本就广泛地使用了流水线作业的思想，大大地提高了浏览器和 Web 服务器之间的传输效率。

### 片断选择算法

一个良好的片断选择策略对于提高下载速度至关重要，对于提高整个文件共享系统的性能也有重要影响。

片断选择的第一个策略是，一旦向某个 peer 发送对某个 piece 中的 slice 的请求后，则该 piece 中的其他 slice 也从该 peer 处下载，这样可以尽快地下载到一个完整的 piece。因为某个 peer 拥有某个 piece 中的一个 slice，则它必定拥有该 piece 的其他 slice，并且如果 peer 愿意发送一个 slice 给客户端，它也应该愿意发送 piece 中的其他 slice 给客户端。该策略也被称为严格的优先级。

片断选择的第二个策略是，最少优先。即某个 piece 在所有 peer 中的拥有率最低，则优先下载该piece。这么做的优点是，第一，可以防止拥有这个 piece 的 peer 突然离开，导致某个 piece 的缺失，从而当前任何一个参与下载的peer都不能下载到一份完整的文件；第二，如果下载了某些拥有率较低的piece，则其他很多peer会向客户端请求数据，而要想从客户端下载到数据，那些peer就要提供数据给客户端下载，这样对于提高客户端的下载速度也是有帮助的。对于这个共享系统而言，优先下载拥有率较低的piece可以使得整个系统提高每个piece的拥有度，整个系统会趋向于最优。如果所有peer优先下载拥有率较高的piece，会使某些piece的拥有率进一步降低，而拥有这些低拥有率piece的peer一旦离开共享系统，则整个文件会越来越不完整，最后导致许多peer不能下载到一个完整的文件拷贝。

片断选择的第三个策略是，随机选择第一个要下载的piece。开始下载时，不能采用最少优先策略。原因在于，采用最少优先策略，如果某个piece的拥有率很低，那么下载到这个piece就相对较难。如果随机选择一个piece，那么更容易下载到该piece，一旦客户端下载到一个完整的piece，就可以提供给其他peer下载，而由于客户端向其他peer上传数据，会导致其他peer对客户端解除阻塞，从而有利于在起始阶段获得较高的下载速度。当然在下载到一些piece后，客户端应该采用最少优先策略来下载数据，这虽然会导致客户端的下载速度在短期内有所下降，但随后下载速度会有较大提高。

片断选择的第四个策略是，最后阶段模式。有时，从一个传输速度很慢的peer处下载一个piece会花费很长时间，在下载的过程中这不是什么大问题。但在下载接近完成时，如果发生这种情况，会导致客户端迟迟不能下载完成。为了解决这个问题，在最后阶段，客户端向所有peer发送对这个piece的某些slice的请求，一旦收到某个peer发来的slice，则向其他peer发送cancel消息，只从当前这个peer处下载。

### 阻塞算法

BT并不集中分配资源，每个peer有责任尽可能地提高自己的下载速度。peer从它可以连接的peer下载文件，并根据对方提供的下载速率给予同等的上传回报，对于合作者，提供上传服务，对于不合作的，就阻塞对方。阻塞是一种临时拒绝上传的策略，虽然上传停止了，但是下载仍然继续。在解除阻塞时，连接并不需要重新建立。因为阻塞过程中只是拒绝传输piece消息，其他消息，如have消息，interested消息仍可以传输。阻塞算法虽然不是BT协议一部分，但是它对提高性能是必要的。

每个客户端一直与固定数量的peer保持疏通（通常是4个），那么以什么方式来决定是否保持与某个peer疏通呢？通常的做法是，严格地根据当前的下载速度来决定哪些peer应该保持疏通。但计算当前下载速度是个大难题。当前的实现通常是计算最近10秒从每个peer处下载数据的速度。以10秒为间隔重新选择保持疏通（即解除阻塞）的peer，是为了避免频繁地阻塞和解阻塞，造成资源的浪费。实践表明，10秒足以使下载速度达到最大。

如果只是简单地为提供最高下载速率的4个peer提供上载服务，那么就没有办法发现那些空闲的连接是否有更好的下载速度。为了解决这个问题，在任何时候，每个peer都拥有一个称为“optimistic unchoking（优化非阻塞）”peer，这个连接总是保持疏通状态，而不管它的下载速率是多少。每隔30秒，重新选择一个peer作为优化非阻塞peer。30秒足以让该peer的上载能力达到最大。

一旦某个peer完成了下载，它不能再通过下载速率（因为下载速率已经为0了）来决定为哪些peer提供上载了。目前采用的解决办法是，优先选择那些从它这里得到更好下载速率的peer，保持与它们疏通。这样做的理由是尽可能的利用上载带宽。一旦某个peer完成了下载，那么它也就成为了种子。种子拥有一份完整的文件拷贝，并提供给其他peer下载。为了整个系统的性能，每个peer在完成下载后应该作为种子存在一段时间，作为对整个系统的回报。原始种子，即最初提供文件进行共享、并制作生成了种子文件，并把种子文件发布到Web服务器的种子，它至少应该存在到系统中生成另外一个种子时才能离开，否则当前参与下载的所有peer都不能获得一份完整的文件拷贝。




- [目录](SUMMARY.md)
- 上一节：[S/Kademlia 协议](03.4.md)
- 下一节：[分布式版本控制(Git)](03.6.md)
